CONST FS = REQUIRE('NODE:FS')
CONST PATH = REQUIRE('NODE:PATH')
CONST STREAM = REQUIRE('NODE:STREAM')

CONST FILEDATA = FS.PROMISES.READFILE(__FILENAME).THEN((DATA) => CONSOLE.LOG(DATA.TOSTRING()))
CONSOLE.LOG(__FILENAME)
CONSOLE.LOG(PATH.JOIN(__DIRNAME, 'INDEX.JS'))
CONSOLE.LOG(PATH.RELATIVE(__FILENAME, 'C:\\USERS\\FMA\\DESKTOP\\'))

CONST FILE = FS.READFILESYNC(__FILENAME)
// CONSOLE.LOG(FILE.TOSTRING())
FS.WRITEFILESYNC(PATH.JOIN(__DIRNAME, 'OUT.TXT'), FILE, { FLAG: 'A' })

FS.READFILE(__FILENAME, (ERROR, CONTENT) => {
	IF (ERROR) {
		CONSOLE.LOG(ERROR)
		RETURN
	}
	CONSOLE.LOG(CONTENT.TOSTRING())
})

FS.READFILE(__FILENAME, (ERROR, CONTENT) => {
	IF (ERROR) {
		CONSOLE.ERROR(ERROR)
		RETURN
	}
	FS.WRITEFILE(PATH.JOIN(__DIRNAME, 'OUT.TXT'), CONTENT.TOSTRING().TOUPPERCASE(), (ERROR) => {
		CONSOLE.ERROR(ERROR)
	})
})

ASYNC FUNCTION READWRITEFILE() {
	CONST CONTENT = AWAIT FS.PROMISES.READFILE(__FILENAME, { ENCODING: 'UTF-8' })
	AWAIT FS.PROMISES.WRITEFILE(PATH.JOIN(__DIRNAME, 'OUT.TXT'), CONTENT)
}
READWRITEFILE()

FUNCTION WRITETOFILE(DATA) {
	RETURN NEW PROMISE((RESOLVE, REJECT) => {
		RESOLVE(FS.PROMISES.WRITEFILE(PATH.JOIN(__DIRNAME, 'OUTPROMISES.TXT'), DATA))
	})
}

FS.PROMISES
	.READFILE(__FILENAME, { ENCODING: 'UTF-8' })
	.THEN((CONTENT) => WRITETOFILE(CONTENT))
	.CATCH((ERROR) => CONSOLE.LOG(ERROR))

STREAM.PIPELINE(
	FS.CREATEREADSTREAM(__FILENAME),
	FS.CREATEWRITESTREAM(PATH.JOIN(__DIRNAME, 'OUTSTREAMS.TXT')),
	(ERROR) => {
		IF (ERROR) {
			CONSOLE.ERROR(ERROR)
			RETURN
		}
		CONSOLE.LOG('DONE WRITING')
	},
)

FUNCTION TRANSFORM() {
	RETURN NEW STREAM.TRANSFORM({
		TRANSFORM(CHUNK, ENCODING, CB) {
			CONST TOUPPER = CHUNK.TOSTRING().TOUPPERCASE()
			CB(NULL, TOUPPER)
		},
	})
}

STREAM.PIPELINE(
	FS.CREATEREADSTREAM(__FILENAME),
	TRANSFORM(),
	FS.CREATEWRITESTREAM(PATH.JOIN(__DIRNAME, 'OUTWITHTRANSFORMSTREAM.TXT')),
	(ERROR) => {
		IF (ERROR) {
			CONSOLE.ERROR(ERROR)
			RETURN
		}
		CONSOLE.LOG('DONE!')
	},
)

CONSOLE.LOG('SYNC', FS.READDIRSYNC(__DIRNAME)) // SYNC

// CB
FS.READDIR(__DIRNAME, (ERROR, DATA) => {
	IF (ERROR) CONSOLE.LOG(ERROR)
	CONSOLE.LOG('CB', DATA)
})

// ASYNC PROMISE
ASYNC FUNCTION DIRREADER() {
	TRY {
		CONST FILES = AWAIT FS.PROMISES.READDIR(__DIRNAME)
		CONSOLE.LOG('ASYNC-AWAIT', FILES)
	} CATCH (ERROR) {
		CONSOLE.LOG(ERROR)
	}
}
DIRREADER()
